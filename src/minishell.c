#include <errno.h>
#include <limits.h>
#include <pwd.h>
#include <signal.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

#define BRIGHTBLUE "\x1b[34;1m"
#define DEFAULT "\x1b[0m"
#define MAX_COMLEN 4096
#define MAX_TOKENS 2048

void free_tokens(char **a);
void display_usage(void);
void catch_sigint(int sig);
int main(int a, char **b);

void free_tokens(char **tokens){
    int i = 0;
    while(tokens[i] != NULL){
        free(tokens[i++]);
    }
}

void display_usage(void){
    fprintf(stdout, "Usage: ./minishell <no arguments>\n");
}

volatile sig_atomic_t interrupted = false;

void catch_sigint(int sig) {
    interrupted = true;
}

int main(int argc, char **argv){

    if (argc != 1){
        display_usage();
        return EXIT_SUCCESS;
    }

    struct sigaction action;
    memset(&action, 0, sizeof(struct sigaction));
    action.sa_handler = catch_sigint;

    if(sigaction(SIGINT, &action, NULL) == -1){
        fprintf(stderr, "Error: Cannot register signal handler. %s\n", strerror(errno));
        return EXIT_FAILURE;
    }

    char buf[MAX_COMLEN];
    char cwd[PATH_MAX];

    while(true){
        if(getcwd(cwd, sizeof(cwd)) == NULL){
            fprintf(stderr, "Error: Cannot get current working directory. %s.\n", strerror(errno));
            return EXIT_FAILURE;
        }

        printf("[%s%s%s]$ ", BRIGHTBLUE, cwd, DEFAULT);
        fflush(stdout);

        if(fgets(buf, sizeof(buf), stdin) == NULL){
            if(errno == EINTR){
                printf("\n");
                errno = 0;
                interrupted = false;
                continue;
            }
            // if end of file is encountered, break and end
            // this is similar to the behavior exihibited by
            // the provided executable, where a text file redirected to
            // the program's stdin causes it to exit after reading all 
            // the instructions in the text file
            else if(feof(stdin)){
                printf("\n");
                break;
            }
            else if(ferror(stdin)){
                fprintf(stderr, "Error: Failed to read from stdin. %s.\n", strerror(errno));
                return EXIT_FAILURE;
            }
        }

        if(!strcmp(buf, "\n")){
            continue;
        }

        // Null-terminating the input
        char *eoln = strchr(buf, '\n');
        if(eoln != NULL){
            *eoln = '\0';
        }
        
        // If input is exit, exit the while loop and EXIT_SUCCESS
        if(!strcmp(buf, "exit")){
            break;
        }

        // set up a copy of buf to use when
        // there are quotations to deal with
        char buf_copy[MAX_COMLEN];
        strcpy(buf_copy, buf);

        // setting up the necessary array for tokens
        // generated by strtok to be put into
        char *tokens[MAX_TOKENS];
        char *token = strtok(buf, " ");
        int count = 0;
        int mem_loss = 0;

        while(token != NULL){
            tokens[count] = malloc(strlen(token) + 1);
            if(tokens[count] == NULL){
                free_tokens(tokens);
                mem_loss = 1;
                fprintf(stderr, "Error: malloc() failed. %s.\n", strerror(errno));
                break;
            }
            strcpy(tokens[count], token);
            token = strtok(NULL, " ");
            count++;
        }

        tokens[count] = NULL;

        // if there was a failure to malloc
        // skip this iteration
        if(mem_loss){
            continue;
        }

        // should exit if first command was exit
        // even with junk after it
        // minishell does not handle exit
        // if it's after some other commands
        // similar to the provided executable
        if(!strcmp(tokens[0], "exit")){
            free_tokens(tokens);
            break;
        }

        // Dealing with cd
        // if any errors are encountered,
        // free memory allocated to tokens array
        if(!strcmp(tokens[0], "cd")){
            bool does_not_contain_q = true;
            for(int j = 3; j < strlen(buf_copy); j++){
                if(buf_copy[j] == '"'){
                    does_not_contain_q = false;
                    break;
                }
            }
            char first;
            char tilde = '~';
            if(count != 1){
                first = tokens[1][0];
            }
            struct passwd *pws;
            if((pws = getpwuid(getuid())) == NULL){
                fprintf(stderr, "Error: Cannot get passwd entry. %s.\n", strerror(errno));
                free_tokens(tokens);
                continue;
            }
            if(count > 2 && does_not_contain_q){
                fprintf(stderr, "Error: Too many arguments to cd.\n");
                free_tokens(tokens);
                continue;
            }
            else if(count == 1 || !strcmp(tokens[1], "~")){
                if((chdir(pws->pw_dir)) == -1){
                    fprintf(stderr, "Error: Cannot change directory to '%s'. %s.\n", pws->pw_dir, strerror(errno));
                    free_tokens(tokens);
                    continue;
                }
                // free tokens array after chdir executes normally
                // and continue to next iteration
                free_tokens(tokens);
                continue;
            }
            // deals with expanding the tilde when there are no quotations
            // in any part of the commands
            else if(first == tilde && does_not_contain_q){
                char substr[strlen(tokens[1])+1];
                strncpy(substr, tokens[1] + 1, strlen(tokens[1]) -1);
                substr[strlen(tokens[1])-1] = '\0';
                char *expanded = malloc(strlen(tokens[1]) + strlen(pws->pw_dir));
                if(expanded == NULL){
                    fprintf(stderr, "Error: malloc() failed. %s.\n", strerror(errno));
                    free_tokens(tokens);
                    continue;
                }
                strcpy(expanded, pws->pw_dir);
                strcat(expanded, substr);
                if((chdir(expanded)) == -1){
                    fprintf(stderr, "Error: Cannot change directory to '%s'. %s.\n", expanded, strerror(errno));
                    free_tokens(tokens);
                    free(expanded);
                    continue;
                }
                free_tokens(tokens);
                free(expanded);
                continue;
            }
            // deals with quotations in cd command
            else if(!does_not_contain_q){
                free_tokens(tokens);
                int num_of_q = 0;
                // bool for too many arguments
                bool tma = false;
                char command[strlen(buf_copy) + 1];
                int index = 0;
                // assuming the amount of spaces that are provided
                // to cd is correct
                // copy the commands provided into the command
                // array, not including the quotations
                for(int i = 3; i < strlen(buf_copy); i++){
                    if(buf_copy[i] == '"'){
                        num_of_q++;
                    }
                    else if(num_of_q % 2 == 0 && buf_copy[i] == ' '){
                        tma = true;
                    }
                    else{
                        command[index] = buf_copy[i];
                        index++;
                    }

                }
                // Malformed commands taking precedence
                if(num_of_q % 2 != 0){
                    fprintf(stderr, "Error: Malformed command.\n");
                    continue;
                }
                // Too many arguments are dealt after malformed error
                if(tma){
                    fprintf(stderr, "Error: Too many arguments.\n");
                    continue;
                }
                // null terminate the command string
                command[index] = '\0';
                // if the first argument is tilde
                // expand it
                if(command[0] == tilde){
                    char substr[strlen(command) + 1];
                    strncpy(substr, command + 1, strlen(command) -1);
                    substr[strlen(command)-1] = '\0';
                    char *expanded = malloc(strlen(command) + strlen(pws->pw_dir));
                    if(expanded == NULL){
                        fprintf(stderr, "Error malloc() failed. %s.\n", strerror(errno));
                        continue;
                    }
                    strcpy(expanded, pws->pw_dir);
                    strcat(expanded, substr);
                    if((chdir(expanded)) == -1){
                        fprintf(stderr, "Error: Cannot change directory to '%s'. %s.\n", expanded, strerror(errno));
                        free(expanded);
                        continue;
                    }
                    free(expanded);
                    continue;
                }

                if((chdir(command)) == -1){
                    fprintf(stderr, "Error: Cannot change directory to '%s'. %s.\n", command, strerror(errno));
                    continue;
                }
                continue;
            }
            // deal with normal input and 
            // cd into the provided directory
            else{
                if((chdir(tokens[1])) == -1){
                    fprintf(stderr, "Error: Cannot change directory to '%s'. %s.\n", tokens[1], strerror(errno));
                    free_tokens(tokens);
                    continue;
                }
                // free tokens array after chdir executes normally
                // and continue to next iteration
                free_tokens(tokens);
                continue;
            }
        }

        // Deal with all other functions by exec'ing
        // Set up pid_t pid for forking
        pid_t pid;

        if((pid = fork()) < 0){
            fprintf(stderr, "Error: fork() failed. %s.\n", strerror(errno));
            free_tokens(tokens);
            continue;
        }

        // child process exec'ing the command
        if(pid == 0){
            if(execvp(tokens[0], tokens) == -1){
                fprintf(stderr, "Error: exec() failed. %s.\n", strerror(errno));
                free_tokens(tokens);
                return EXIT_FAILURE;
            }
        }
        // parent process
        else{
            int status;
            pid_t w;
            // keep checking the status of the child, and if the child
            // is interrupted, kill the child process
            while((w = waitpid(pid, &status, WNOHANG)) == 0){
                if(interrupted){
                    kill(pid, SIGTERM);
                    interrupted = false;
                    printf("\n");
                }
            }
            if(w == -1){
                fprintf(stderr, "Error: wait() failed. %s.\n", strerror(errno));
            }
            // free memory
            free_tokens(tokens);
            // set interrupted to false
            // as ^C could have been called earlier
            interrupted = false;
        }
    }

    // outside while loop
    return EXIT_SUCCESS;
}

